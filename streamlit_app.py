import streamlit as st
import geopandas as gpd
import folium
from branca.colormap import LinearColormap
import pickle
import numpy as np
from PIL import Image
import base64
from pathlib import Path
import io

st.set_page_config(layout="wide")

# Custom CSS for logo alignment
st.markdown("""
<style>
.logo-container {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: 20px;
    padding: 10px 0;
}
.logo-container img {
    object-fit: contain;
}
</style>
""", unsafe_allow_html=True)

with open('village_agg_per_district_modified.pkl', 'rb') as f:
    district_gdfs = pickle.load(f)

# Function to resize image
def resize_image(image, width):
    w_percent = width / float(image.size[0])
    h_size = int(float(image.size[1]) * float(w_percent))
    return image.resize((width, h_size), Image.LANCZOS)

logo_dir = Path("Logos")
logo_files = list(logo_dir.glob("*.png")) + list(logo_dir.glob("*.jpg")) + list(logo_dir.glob("*.jpeg"))
LOGO_WIDTH = 75

# Create a container for logos
logo_container = st.container()
logo_html = '<div class="logo-container">'

for logo_file in logo_files:
    logo_image = Image.open(logo_file)
    resized_logo = resize_image(logo_image, LOGO_WIDTH)
    
    # Convert PIL image to bytes
    buf = io.BytesIO()
    resized_logo.save(buf, format="PNG")
    img_str = base64.b64encode(buf.getvalue()).decode()
    
    # Add image to HTML string
    logo_html += f'<img src="data:image/png;base64,{img_str}" style="height:{LOGO_WIDTH}px; width:auto;">'

logo_html += '</div>'

# Display logos
logo_container.markdown(logo_html, unsafe_allow_html=True)
with open('village_agg_per_district_modified.pkl', 'rb') as f:
    district_gdfs = pickle.load(f)  # This is now a dictionary of GeoDataFrames keyed by district name

st.title('Vulnerability Mapping for Uttar Pradesh')

districts = sorted(district_gdfs.keys())
selected_district = st.sidebar.selectbox('Select a district', districts)

# Filter GeoDataFrame based on selected district
district_gdf = district_gdfs[selected_district]

# Sidebar - Layer selection
layer_type = st.sidebar.radio('Select Layer', ['Villages','Subdistricts'])

# Get unique subdistricts and add 'All' option
subdistricts = ['All'] + sorted(district_gdf['subdistrict'].unique().tolist())

# Conditionally render the subdistrict dropdown
if layer_type == 'Villages':
    selected_subdistrict = st.sidebar.selectbox('Select a subdistrict', subdistricts)
else:
    st.sidebar.text('Select a subdistrict')
    selected_subdistrict = 'All'

# Filter GeoDataFrame based on selected subdistrict
if selected_subdistrict != 'All':
    filtered_gdf = district_gdf[district_gdf['subdistrict'] == selected_subdistrict]
else:
    filtered_gdf = district_gdf

if layer_type == 'Villages':
    groupby_column = 'name'
else:
    # Group by subdistrict and dissolve
    filtered_gdf = filtered_gdf.dissolve(by='subdistrict', aggfunc={
        'tot_p': 'sum',
        'no_hh': 'sum',
        'avghhsz_cy': 'mean',
        'weighted_proba_case_count': 'sum',
        'normalized_risk_score':'sum',
        'district': 'first'
    }).reset_index()
    groupby_column = 'subdistrict'

# moving map to centroid of selected geometry
centroids = filtered_gdf.geometry.centroid
center_point = centroids.unary_union.centroid

# Check if normalized_risk_score exists and handle None values
if 'normalized_risk_score' in filtered_gdf.columns:
    # Replace None values with 0
    filtered_gdf['normalized_risk_score'].fillna(0, inplace=True)

# determine which score column to use based on normalised risk score checkbox
score_column = 'normalized_risk_score' if st.sidebar.checkbox('Normalize risk score by population?', value=True) else 'weighted_proba_case_count'

# setting top 5 villages to highest colour to correct for skew
def get_color(score, colormap, is_top_5=False):
    if is_top_5:
        return '#FF0000'  # Bright red for top 5
    return colormap(score)

# Create the base map
m = folium.Map(location=[center_point.y, center_point.x], zoom_start=10)

# Identify top 5 villages only if in 'Villages' layer
if layer_type == 'Villages':
    top_5_villages = filtered_gdf.nlargest(5, score_column)
    top_5_names = set(top_5_villages[groupby_column])
    
    # Excluding top 5 villages to correct for skew
    remaining_villages = filtered_gdf[~filtered_gdf[groupby_column].isin(top_5_names)]
    min_score = remaining_villages[score_column].min()
    max_score = remaining_villages[score_column].max()
else:
    top_5_names = set()  # Empty set for Subdistricts layer
    min_score = filtered_gdf[score_column].min()
    max_score = filtered_gdf[score_column].max()

# Create colormap
colormap = LinearColormap(
    colors=['#40c040', '#a0e0a0', '#ffff00', '#ffd700', '#ffa500', '#ff4500', '#ff0000'],
    vmin=min_score,
    vmax=max_score
)

# Determine the legend title based on the score column
legend_title = "Population Normalised Risk Score" if score_column == 'normalized_risk_score' else "Risk Score"

# Determine the legend title based on the score column
legend_title = "Population Normalised Risk Score" if score_column == 'normalized_risk_score' else "Risk Score"

# Set the caption for the colormap (this will be the legend title)
colormap.caption = legend_title

# Add GeoDataFrame to the map with GeoJson
folium.GeoJson(
    filtered_gdf,
    name=layer_type,
    style_function=lambda feature: {
        'fillColor': get_color(
            feature['properties'][score_column],
            colormap,
            layer_type == 'Villages' and feature['properties'][groupby_column] in top_5_names
        ),
        'color': 'black',
        'weight': 1,
        'fillOpacity': 0.7,
    },
    tooltip=folium.GeoJsonTooltip(
        fields=[groupby_column, 'district', 'tot_p', 'no_hh', 'avghhsz_cy', score_column],
        aliases=[f'{layer_type[:-1]}:', 'District:', 'Population:', 'Households:', 'Avg. Household Size:', 'Risk Score:'],
        localize=True,
        style=('background-color: white; color: #333333; font-family: arial; font-size: 12px; padding: 10px;')
    ),
).add_to(m)

# Add color legend
colormap.add_to(m)

# Add layer control
folium.LayerControl().add_to(m)

# Save the map to HTML string
map_html = m._repr_html_()

st.subheader(f"Map of {selected_district} - {layer_type}")

# Display the map using custom HTML
st.components.v1.html(f"""
    <div style="width: 100%; height: 100vh;">
        <h3></h3>
        {map_html}
    </div>
""", height=700)

# Create and display the distribution table
if layer_type == 'Villages':
    st.subheader("Village Distribution by Risk Score")

    # Sort the dataframe by the score column
    sorted_df = filtered_gdf.sort_values(by=score_column, ascending=False)

    # Calculate the number of villages in each category
    total_villages = len(sorted_df)
    top_25_count = int(total_villages * 0.25)
    middle_50_count = int(total_villages * 0.5)
    bottom_25_count = total_villages - top_25_count - middle_50_count

    # Split the dataframe into three parts
    top_25 = sorted_df.head(top_25_count)
    middle_50 = sorted_df.iloc[top_25_count:top_25_count+middle_50_count]
    bottom_25 = sorted_df.tail(bottom_25_count)

    # Function to format dataframe for display
    def format_df_for_display(df):
        return df[[groupby_column, 'tot_p', score_column]].rename(columns={
            groupby_column: 'Village Name',
            'tot_p': 'Population',
            score_column: 'Risk Score'
        })

    # Create three columns for the table
    col1, col2, col3 = st.columns(3)

    with col1:
        st.markdown("**High Risk (Top 25%) Villages**")
        st.dataframe(format_df_for_display(top_25), height=400)

    with col2:
        st.markdown("**Medium Risk (Middle 50%) Villages**")
        st.dataframe(format_df_for_display(middle_50), height=400)

    with col3:
        st.markdown("**Low Risk (Bottom 25%) Villages**")
        st.dataframe(format_df_for_display(bottom_25), height=400)

else:
    st.info("Please select 'Villages' layer to view the distribution table.")

# Add footnote
st.markdown("---")
st.subheader("Additional Information")

# List of features
features = [
    "Relative Wealth", "Population Density", "Urbanisation", "Night Luminosity",
    "Carbon Monoxide", "Formaldehyde Level", "Nitrogen Dioxide", "Sulfur Dioxide",
    "Surface Temperature", "Fire Duration", "Grass Coverage", "Crop Coverage",
    "Human Modification", "Bare Land", "Water Bodies", "Wetland Coverage",
    "Moss Coverage", "Evergreen Needleleaf", "Evergreen Broadleaf",
    "Deciduous Needleleaf", "Deciduous Broadleaf", "Mixed Forest",
    "Unknown Forest", "Open Needleleaf", "Open Broadleaf", "Open Deciduous",
    "Open Broadleaf", "Open Mixed", "Open Unknown", "Forest Proximate People",
    "Surface Water"
]

st.markdown("### Features Used")
st.write(", ".join(features))

st.markdown("### Note on Risk Score")
st.write("""
The risk score is a derived score from model outputs, which are probability scores assigned to different case-count buckets. 
This is not to be interpreted directly as predicted case count. Please also note that the colour coding is relative and depends on the set of districts used.
""")
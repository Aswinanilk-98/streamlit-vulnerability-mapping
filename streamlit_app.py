import streamlit as st
import geopandas as gpd
import folium
from branca.colormap import LinearColormap
import pickle
import numpy as np

st.set_page_config(layout="wide")

with open('village_agg_per_district_modified.pkl', 'rb') as f:
    district_gdfs = pickle.load(f)  # This is now a dictionary of GeoDataFrames keyed by district name

st.sidebar.title('Vulnerability Mapping for Uttar Pradesh')

districts = sorted(district_gdfs.keys())
selected_district = st.sidebar.selectbox('Select a district', districts)

# Filter GeoDataFrame based on selected district
district_gdf = district_gdfs[selected_district]

# Sidebar - Layer selection
layer_type = st.sidebar.radio('Select Layer', ['Subdistricts','Villages'])

# Get unique subdistricts and add 'All' option
subdistricts = ['All'] + sorted(district_gdf['subdistrict'].unique().tolist())

# Conditionally render the subdistrict dropdown
if layer_type == 'Villages':
    selected_subdistrict = st.sidebar.selectbox('Select a subdistrict', subdistricts)
else:
    st.sidebar.text('Select a subdistrict')
    selected_subdistrict = 'All'

# Filter GeoDataFrame based on selected subdistrict
if selected_subdistrict != 'All':
    filtered_gdf = district_gdf[district_gdf['subdistrict'] == selected_subdistrict]
else:
    filtered_gdf = district_gdf

if layer_type == 'Villages':
    groupby_column = 'name'
else:
    # Group by subdistrict and dissolve
    filtered_gdf = filtered_gdf.dissolve(by='subdistrict', aggfunc={
        'tot_p': 'sum',
        'no_hh': 'sum',
        'avghhsz_cy': 'mean',
        'weighted_proba_case_count': 'sum',
        'normalized_risk_score':'mean',
        'district': 'first'
    }).reset_index()
    groupby_column = 'subdistrict'

# moving map to centroid of selected geometry
centroids = filtered_gdf.geometry.centroid
center_point = centroids.unary_union.centroid

# Check if normalized_risk_score exists and handle None values
if 'normalized_risk_score' in filtered_gdf.columns:
    # Replace None values with 0
    filtered_gdf['normalized_risk_score'].fillna(0, inplace=True)

# determine which score column to use based on normalised risk score checkbox
score_column = 'normalized_risk_score' if st.sidebar.checkbox('Normalize risk score by population?', value=True) else 'weighted_proba_case_count'

# Function to get color based on score
def get_color(score, colormap, is_top_5=False):
    if is_top_5:
        return '#FF0000'  # Bright red for top 5
    return colormap(score)

# Create the base map
m = folium.Map(location=[center_point.y, center_point.x], zoom_start=10)

# Identify top 5 villages only if in 'Villages' layer
if layer_type == 'Villages':
    top_5_villages = filtered_gdf.nlargest(5, score_column)
    top_5_names = set(top_5_villages[groupby_column])
    
    # Calculate min and max scores for remaining villages
    remaining_villages = filtered_gdf[~filtered_gdf[groupby_column].isin(top_5_names)]
    min_score = remaining_villages[score_column].min()
    max_score = remaining_villages[score_column].max()
else:
    top_5_names = set()  # Empty set for Subdistricts layer
    min_score = filtered_gdf[score_column].min()
    max_score = filtered_gdf[score_column].max()

# Create colormap
colormap = LinearColormap(
    colors=['#40c040', '#a0e0a0', '#ffff00', '#ffd700', '#ffa500', '#ff4500', '#ff0000'],
    vmin=min_score,
    vmax=max_score
)

# Add GeoDataFrame to the map with GeoJson
folium.GeoJson(
    filtered_gdf,
    name=layer_type,
    style_function=lambda feature: {
        'fillColor': get_color(
            feature['properties'][score_column],
            colormap,
            layer_type == 'Villages' and feature['properties'][groupby_column] in top_5_names
        ),
        'color': 'black',
        'weight': 1,
        'fillOpacity': 0.7,
    },
    tooltip=folium.GeoJsonTooltip(
        fields=[groupby_column, 'district', 'tot_p', 'no_hh', 'avghhsz_cy', score_column],
        aliases=[f'{layer_type[:-1]}:', 'District:', 'Population:', 'Households:', 'Avg. Household Size:', 'Risk Score:'],
        localize=True,
        style=('background-color: white; color: #333333; font-family: arial; font-size: 12px; padding: 10px;')
    ),
).add_to(m)

# Add color legend
colormap.add_to(m)

# Add layer control
folium.LayerControl().add_to(m)

# Save the map to HTML string
map_html = m._repr_html_()

# Display the map using custom HTML
st.components.v1.html(f"""
    <div style="width: 100%; height: 100vh;">
        <h3>Map of {selected_district} - {layer_type} colored by Risk Score</h3>
        {map_html}
    </div>
""", height=700)

# Display top 5 villages and their colors only for Villages layer
if layer_type == 'Villages':
    st.subheader("Top 5 Villages by Risk Score")
    
    # Create a color column for the top 5 villages
    top_5_villages['Color'] = ['#FF0000'] * len(top_5_villages)  # Bright red for all top 5
    
    # Display the table with custom formatting for the color column
    st.write(
        top_5_villages[[groupby_column, score_column, 'Color']]
        .to_html(escape=False, formatters={
            'Color': lambda x: f'<span style="color:{x};">â– </span>'
        }, index=False),
        unsafe_allow_html=True
    )
else:
    st.write("Top 5 list is only available when 'Villages' layer is selected.")

# Display statistics
st.subheader(f'Statistics for {selected_district}')
if selected_subdistrict != 'All' and layer_type == 'Villages':
    st.write(f"Subdistrict: {selected_subdistrict}")
st.write(f"Number of {layer_type.lower()}: {len(filtered_gdf)}")
st.write(f"Total population: {filtered_gdf['tot_p'].sum():.0f}")
st.write(f"Average household size: {filtered_gdf['avghhsz_cy'].mean():.2f}")
st.write(f"Average risk score: {filtered_gdf[score_column].mean():.4f}")
st.write(f"Min risk score: {min_score:.4f}")
st.write(f"Max risk score: {max_score:.4f}")